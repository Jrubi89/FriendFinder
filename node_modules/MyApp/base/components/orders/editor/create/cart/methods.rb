class Orders
  include OrderHelpers

  def place_order order_id, user_id, cart
    order = model.find_by(id: order_id)
    order || halt(400, 'No order found by given ID')

    user = User.find_by(id: user_id)
    user || halt(400, 'No user found by given ID')

    cart = resolved_cart(cart)
    order.total = order.subtotal = cart.map {|row| row[:price] * row[:qty]}.reduce(:+)

    create_order_products(order, cart)

    order.user_id = user.id
    order.transaction_id = order.id
    order.credits_used = order.total * Cfg.credits_per_dollar
    order.status = Order::STATUS_OK
    order.draft = false

    begin :shipping_data
      order.shipping_first_name = user.first_name
      order.shipping_last_name = user.last_name
      order.shipping_email = user.email
      order.shipping_address = user.address
      order.shipping_address2 = user.address2
      order.shipping_zipcode = user.zipcode
      order.shipping_phone = user.phone
      order.shipping_city = user.city
      order.shipping_state = user.state
      order.shipping_country = user.country
    end

    begin :billing_data
      order.billing_first_name = user.first_name
      order.billing_last_name = user.last_name
      order.billing_email = user.email
      order.billing_address = user.address
      order.billing_address2 = user.address2
      order.billing_zipcode = user.zipcode
      order.billing_phone = user.phone
      order.billing_city = user.city
      order.billing_state = user.state
      order.billing_country = user.country
    end

    order.save
    order.mark_products_as_inventory_counted
    editor_serializer(order)
  end

  private
  def resolved_cart cart
    cart.each_with_object([]) do |row,map|

      product = Product.find_by(id: row['product'])
      product || halt(400, 'Cart contains a disabled product with ID: %s' % row['product'].to_i)

      contained_products = nil
      sku = nil

      if row['skus'] && product.contains && product.contains.length > 0

        skus = ProductSKU.where(id: row['skus']).to_a
        skus_products = skus.map(&:product)

        contains = product.contains.each_with_object({}) {|i,o|
          o[i['product_id'].to_i] = i['inventory_items'].to_i
        }

        skus_products.map(&:id).sort == contains.keys.sort ||
          halt(400, 'Wrong SKUs provided for "%s". Please remove it from cart and add again' % product.name)

        contained_products = skus.each_with_object([]) do |sku,o|
          o.push({
            sku: sku,
            product: sku.product,
            inventory_items: contains[sku.product_id]
          })
          sku.freeze
          sku.product.freeze
        end

        sku = product.skus.find_by(default: true)
        sku || halt(400, 'No default SKU detected for "%s"' % product.name)

      elsif row['sku']

        sku = product.skus.find_by(id: row['sku'])

        sku ||
          halt(400, 'No SKU found for "%s. Please remove it from cart and add again"' % product.name)

      end

      sku || halt(400, 'Provided cart contains no SKU/SKUS')

      sku.freeze

      sku.price == row['price'] ||
        halt(400, 'Given price for "%s" differs from price in database' % product.name)

      map.push({
        product: product,
        contained_products: contained_products,
        price: sku.price,
        sku: sku,
        qty: row['qty'],
      })
    end
  end

  def create_order_products order, cart
    cart.each do |row|

      create_order_product(order, row[:product], row[:sku], {
        contains: row[:contained_products] ? true : false,
        product_skus: row[:contained_products] ?
          row[:contained_products].map {|r| {id: r[:sku].id, name: r[:sku].name, inventory_items: r[:inventory_items]}} :
          nil,
        contained: false,
        inventory_items: row[:qty],
        qty: row[:qty]
      })

      row[:contained_products] && row[:contained_products].each do |contained|
        create_order_product(order, contained[:product], contained[:sku], {
          contains: false,
          contained: true,
          inventory_items: contained[:inventory_items] * row[:qty],
          qty: row[:qty]
        })
      end

    end
  end


  def create_order_product order, product, sku, extra
    order.products.create({
      product_id: product.id,
      product_name: product.name,

      product_sku_id: sku.id,
      product_sku_name: sku.name,

      price: sku.price,
      weight: sku.weight,
      size: sku.size,
      color: sku.color,
    }.update(extra))
  end
end

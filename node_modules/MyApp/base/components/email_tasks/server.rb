class EmailTasks < BaseController
  include Crudle::Controller

  EMAILS_PER_TASK = 1000
  LIMIT = 50

  EMAIL_COLUMNS = [
    :user_id,
    :first_name,
    :last_name,
    :email,
    :sent,
    :sent_at,
    :canceled,
    :rejected
  ].freeze

  before do
    if path_params[:task_id]
      @task = model.find_by(id: path_params[:task_id])
      @task || halt(400, 'No Task found by given ID')
    end
  end

  def configs params
    {
      emails: Email.where(uuid: nil).select(:id, :name)
    }
  end

  def fetch_email email_id
    Email.find_by(id: email_id) || halt(400, 'Email not found')
  end

  def emails task_id, filters, offset = 0
    emails_fetcher(@task, filters, offset)
  end

  def is_duplicate_task task_id, email_id
    model.
      where(email_id: email_id).
      where("filters = '%s'::jsonb" % @task.filters.to_json).
      where("started_at > ?", Time.now.utc - 86_400).
      first
  end

  def schedule task_id, params

    @task.update_columns({
      email_id: params[:email_id],
      name: params[:task_name],
      started_at: Time.now.utc
    })

    (0 .. @task.emails.count / EMAILS_PER_TASK).each do |i|
      EmailTask::NewScheduler.perform_async(
        env[:rtcp_serial],
        @task.id,
        params[:email_id],
        params[:subject],
        params[:body],
        i * EMAILS_PER_TASK,
        EMAILS_PER_TASK
      )
    end

    serializer(@task)
  end

  def delete_email task_id, email
    @task.emails.where(email: email, sent: false).delete_all
    true
  end

  def cancel task_id
    task = model.find_by(id: task_id)
    task || halt(400, 'Task not found')
    task.update_column(:canceled, true)
    task.emails.where(sent: false, rejected: false).update_all(canceled: true)
    true
  end

  private
  def model; EmailTask end

  def order; {id: :desc} end

  # def name_filter params, dataset
  #   return if params[:name].nil? || params[:name].empty?
  #   dataset.where('name LIKE ?', params[:name] + '%')
  # end

  # def list_serializer item
  #   serializer(item)
  # end

  def editor_serializer task
    serializer(task).update({
      email: task.email,
      emails: emails_fetcher(task)
    })
  end

  def serializer task
    task.serializable_hash.update(task.status)
  end

  def emails_fetcher task, params = nil, offset = 0
    dataset = task.emails
    total = dataset.count

    if params
      if params[:status]
        dataset = dataset.where(params[:status] => true)
      end

      %w[first_name last_name email].each do |column|
        if params[column] && params[column].length > 0
          dataset = dataset.where("#{column} ILIKE ?", "#{params[column]}%")
        end
      end
    end

    {
      total: total,
      filtered: dataset.count,
      list: dataset.
        limit(LIMIT).
        offset(offset).
        order(:id).
        select(EMAIL_COLUMNS)
    }
  end
end

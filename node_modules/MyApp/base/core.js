import {reduce, forEach, merge, cloneDeep, intersection, isFunction} from 'lodash'
import deepFreeze from 'deep-freeze'

import {RTCP, Router} from 'appril'
import Reporter from 'appril-reporter'
import url from 'appril-url'
import DeployComponent from 'components/deploy'

import Vue from 'vue/dist/vue.js'
import Vuex from 'vuex'
import Logger from 'vuex/logger'

import Components from 'app/components.json'
import {server_url} from 'app/webpack/config.json'

import store_modules from 'base/store/modules'

import crudle_state from 'crudle/vuex/state'
import * as crudle_mutations from 'crudle/vuex/mutations'

const mutations = merge(crudle_mutations, reduce(Object.keys(store_modules), function(f,m) {
  return merge(f, store_modules[m].mutations)
}, {}))

import * as datetime from 'appril-datetime'
import * as utils from 'appril-utils'

Vue.use(Vuex)
Vue.config.devtools = APP_ENV == 'development'

forEach(datetime, (f, n) => Vue.filter(n, f))

Vue.filter('shorten', utils.shorten)
Vue.filter('money_format', utils.money_format)
Vue.filter('phone_format', utils.phone_format)

const consider_idle_after = 5 * 60
const rtcp = new RTCP()

const reservedComponentKeywords = [
  'el',
  'components',
  'props',
  'template',
  'data',
]

const validateConfigs = function(configs) {
  let keywords = intersection(Object.keys(configs), reservedComponentKeywords)
  if (keywords.length > 0)
    throw `ERROR: some reserved keywords used as configs: ${keywords.join(', ')}`
}

const injectConfigs = function(component, options) {

  merge(component, options)

  forEach(component.components || [], function(component) {
    if (isFunction(component))
      return // ignoring async components
    injectConfigs(component, options)
  })
}

rtcp.on_initialize = function(data) {

  deepFreeze(data)

  const componentsMap = reduce(Components, function(map,component) {
    map[component.name] = cloneDeep(component)
    map[component.name].url = utils.urlify(component.url)
    return map
  }, {})

  deepFreeze(componentsMap)

  const rtcpAPI = reduce(Components, function(api,component) {
    api[component.name] = reduce(component.api || [], function(api, method) {
      api[method] = function(...args) {return rtcp.call_server_method(component.url, method, args)}
      return api
    }, {})
    return api
  }, {})

  deepFreeze(rtcpAPI)

  Vue.use(function(vue) {
    Object.defineProperty(vue.prototype, 'component', {
      get() {return this.env.components[this.$root.active_component]}
    })

    Object.defineProperty(vue.prototype, 'api', {
      get() {return this.env.api.rtcp[this.$root.active_component]}
    })

    vue.prototype.url = url

    vue.prototype.env = {
      ...data,
      rtcp,
      api: {rtcp: rtcpAPI},
      components: componentsMap
    }
    // prohibit altering env to avoid anti-patterns
    Object.freeze(vue.prototype.env)
  })

  const router = new Router(Components, data.client_url)

  const state = function() {
    return {
      ...cloneDeep(crudle_state),
      ...reduce(Object.keys(store_modules), function(f,m) {
        f[m] = cloneDeep(store_modules[m].state)
        return f
      }, {})
    }
  }

  mutations.__RESET_COMPONENT_STATE__ = function(state, component) {
    if (store_modules[component] && store_modules[component].state)
      state[component] = cloneDeep(store_modules[component].state)
  }

  const store = new Vuex.Store({
    state: state(),
    mutations,
    strict: APP_ENV == 'development',
    plugins: APP_ENV == 'development' ? [Logger()] : []
  })

  store.subscribe(function({type,payload}, state) {
    if (type === 'CRUDLE__SET_ITEM' && payload === null) {
      store.commit('__RESET_COMPONENT_STATE__', vm.active_component)
    }
  })

  let vm = new Vue({
    store,
    el: '#app',
    data: {
      active_component: null
    },
    template: '<component :is="active_component"></component>',
    components: reduce(componentsMap, function(map, component) {
      map[component.name] = function(resolve, reject) {
        router.load_component(component, function(constructor) {

          rtcpAPI[component.name].configs(url.params).send({
            success(configs) {
              validateConfigs(configs)
              deepFreeze(configs)
              injectConfigs(constructor, configs)
              resolve(DeployComponent(componentsMap, component, constructor))
            },
            error(e) {
              throw e
            }
          })

        }, reject)
      }
      return map
    }, {})
  })

  router.component_matched = function(component) {
    if (vm.active_component === component.name)
      return
    store.replaceState(state())
    vm.active_component = component.name
  }

  router.start()

  Reporter(consider_idle_after, function(status) {
    if (status == 'away')
      rtcp.disconnect() // close connection if user went away
  })
}

document.addEventListener('DOMContentLoaded', function() {
  rtcp.connect({path: `${server_url}/__rtcp__`})
})
